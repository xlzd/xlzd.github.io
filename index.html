<!DOCTYPE html>













<html class="theme-next pisces" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


<meta name="fo-verify" content="6b908db5-b2f5-487e-a145-56e9f72a6221" />



















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=6.4.1">


  <link rel="mask-icon" href="/images/avatar.png?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="blog of xlzd">
<meta property="og:type" content="website">
<meta property="og:title" content="xlzd 杂谈">
<meta property="og:url" content="https://xlzd.me/index.html">
<meta property="og:site_name" content="xlzd 杂谈">
<meta property="og:description" content="blog of xlzd">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xlzd 杂谈">
<meta name="twitter:description" content="blog of xlzd">



  <link rel="alternate" href="/atom.xml" title="xlzd 杂谈" type="application/atom+xml">




  <link rel="canonical" href="https://xlzd.me/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>xlzd 杂谈</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-65835112-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-65835112-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?70df08067fbb3792c8ee0bc6eb269fd8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2933033769298120",
    enable_page_level_ads: true
  });
</script>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xlzd 杂谈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">blog of xlzd</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/xlzd" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/09/18/golang-stop-the-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/golang-stop-the-world/" itemprop="url">
                  Golang 里一个有趣的小细节
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-18 00:43:55" itemprop="dateCreated datePublished" datetime="2018-09-18T00:43:55+08:00">2018-09-18</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天一个小伙伴在公司 slack 问到如下 Golang 代码为什么会卡死（<a href="https://play.golang.org/p/nxo4D832JCo" target="_blank" rel="noopener">Go Playground</a>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++ &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"Dropping mic"</span>)</span><br><span class="line">	<span class="comment">// Yield execution to force executing other goroutines</span></span><br><span class="line">	runtime.Gosched()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题很有意思，大概涉及到 Golang 中以下三个概念：</p>
<ol>
<li>byte 是什么</li>
<li>goroutine 如何调度</li>
<li>Golang GC 时会发生什么</li>
</ol>
<p>本文尝试简单解释下为什么上面的程序会卡死。</p>
<p>首先，先看下 main 函数里启动的 goroutine 事实上是什么东西：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p>
<p>Golang 中，byte 其实被 alias 到 uint8 上了。所以上面的 for 循环会始终成立，因为 i++ 到 i=255 的时候会溢出，<code>i &lt;= 255</code> 一定成立。也即是， for 循环永远无法退出，所以上面的代码其实可以等价于这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，Goroutine 的调度是一个非常复杂的问题，这里并不打算详细介绍完整细节。<br>大概描述一下，目前版本的 Golang 中 goroutine 的调度（<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit" target="_blank" rel="noopener">Scalable Go Scheduler Design Doc</a>）基于 GPM 模型，G 代表 goroutine，M 可以看做真实的资源（OS Threads）。P 是 G-M 的中间层，组织多个 goroutine 跑在同一个 OS Thread 上。大概的模型如下（图偷自 Google 图片搜索）：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45667496-fdcfde80-bb4b-11e8-9c03-d35ef0897685.png" alt="image"></p>
<p>如上图可以看到，一个 P 上会挂着多个 G，当一个 G 执行结束时，P 会选择下一个 G 继续执行。而当一个 G 执行太久没有结束，总也要给后面的 G 运行的机会吧。所以，Go scheduler 除了在一个 goroutine 执行结束时会调度后面的 goroutine 执行，还会在正在被执行的 goroutine 发生以下情况时让出当前 goroutine 的执行权，并调度后面的 goroutine 执行：</p>
<ul>
<li>IO 操作</li>
<li>Channel 阻塞</li>
<li>system call</li>
<li>运行较长时间</li>
</ul>
<p>前三种这里我们不关心，最后一种情况下，如果一个 goroutine 执行时间太长，scheduler 会在其 G 对象上打上一个标志（ preempt），当这个 goroutine 内部<strong>发生函数调用的时候</strong>，会先主动检查这个标志，如果为 true 则会让出执行权。（这里说得比较粗略，实际会复杂一些，不过并不是本文重点所以暂不关注细节。）</p>
<p>回到本文开始时的例子，main 函数里启动的 goroutine 其实是一个没有 IO 阻塞、没有 Channel 阻塞、没有 system call、没有函数调用的死循环。也就是，它无法主动让出自己的执行权，即使已经执行很长时间，scheduler 已经标志了 preempt。</p>
<p>如上图所示，一旦这个 G （ goroutine ） 拿到执行权，它后面的 G 将无法再被当前 P 调度获得执行权。上面程序为了让这个 G 对象一定拿到执行权，在 main goroutine 中主动执行 <code>runtime.Gosched()</code> 让出了执行权。</p>
<p>P 的数量由 GOMAXPROCS 设置，默认为机器的 CPU 数量。</p>
<p>这里又分为两种情况：</p>
<ol>
<li>当这个程序跑在单核机器上的时候，P 默认只有一个，所以一旦调度到这个 G 对象就会卡死，因为永远没有机会再调度回 main goroutine 了。</li>
<li>当这个程序跑在多核机器上的时候，程序到这一步并不会卡死，因为另一个 P 所关联的 G 队列执行完了之后，会通过 Work-Stealing 算法偷取别的 P 对象上的 G，所以 main goroutine 还是有机会被别的 P 调度到。</li>
</ol>
<p>可是文章开始时的代码，不论是在单核的机器上，还是在多核的机器上，都会卡死。</p>
<p>这就涉及到第三个点了：Golang 的 GC。</p>
<p>Golang 的 GC 本质上是基于<strong>标记-清除</strong>实现的（基于此不断改进过）。<br>见名知意，标记-清除分为两个阶段：</p>
<ul>
<li>标记</li>
<li>清除</li>
</ul>
<p>其中，标记阶段是需要 STW（ Stop The World ）的，也就是会让所有正在运行的 goroutine 停下来。大概源码在<a href="https://github.com/golang/go/blob/release-branch.go1.11/src/runtime/mgc.go#L1316" target="_blank" rel="noopener">这个位置</a>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, trigger gcTrigger)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这一步，死循环这个 goroutine 由于上面介绍的原因永远无法停下来，但是 main goroutine 阻塞在 GC STW 这里，等待所有 goroutine 停止执行。main goroutine 在等待一个永远不会为它停下的 G，于是，程序卡死了。</p>
<p>类似的，在设置 GOMAXPROCS 的时候，也需要 STW，所以下面的代码，和本文开始时的代码，卡死的原因是一样一样的（<a href="https://play.golang.org/p/vvuD1smj9RM" target="_blank" rel="noopener">Go Playground</a>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forever</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> forever()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)  <span class="comment">// 让出执行权</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1926</span>)      <span class="comment">// 等待 stw</span></span><br><span class="line">	fmt.Println(<span class="string">"Done"</span>)           <span class="comment">// 永远执行不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区区几行代码，里面的奥妙真不少呀。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/09/14/why-mysql-innodb-need-auto-increment-primary-key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/why-mysql-innodb-need-auto-increment-primary-key/" itemprop="url">
                  为什么建议 MySQL InnonDB 的表使用递增的主键 ID
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 21:33:53" itemprop="dateCreated datePublished" datetime="2018-09-14T21:33:53+08:00">2018-09-14</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>经验较少的程序员在设计数据表的时候，经常会听到 DBA 老鸟建议在表上使用递增的主键 ID，而不是使用 UUID 等方式产生 ID。大体的措辞都是 InnoDB 使用自增的主键更快云云，本文尝试阐述为什么需要这样做。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>在 InnoDB 中，每个表都会有一个<strong>聚簇索引</strong>，在定义了主键（ primary key ）的情况下，主键所在的列会被作为聚簇索引存储。所谓聚簇索引，意思是数据实际上是存储在索引的叶子节点上，「聚簇」的含义就是数据行和相邻的数据紧凑地存储在一起。因为不能（或者不值得）同时把数据行存储在两个不同的位置，所以一个表只能有一个聚簇索引。</p>
<p>关于 InnoDB 选择哪个列作为聚簇索引存储，大概的优先级为：</p>
<ol>
<li>如果定义了主键（ primary key ），则使用主键；</li>
<li>如果没有定义主键，则选择第一个不包含 NULL（ NOT NULL ）的 UNIQUE KEY；</li>
<li>如果也没有，则会隐式定义一个主键作为聚簇索引。</li>
</ol>
<p>下图展示了聚簇索引中记录（数据）是如何存放的：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45551535-d71a5b00-b860-11e8-914b-ff6bba012b17.png" alt="image"></p>
<p>如上图所示，聚簇索引中，不但存储了索引，还存储了整张表的数据到叶子节点上。可以认为 InnoDB 中，聚簇索引「就是」表。对应的，InnoDB 的其它索引中，叶子节点所存储的，其实是主键的值。存储主键的值而不是数据行的位置，这样的存储方式可以减少当出现数据行移动或者数据页分裂时二级索引的维护工作。</p>
<h2 id="聚簇与非聚簇表的数据存储方式"><a href="#聚簇与非聚簇表的数据存储方式" class="headerlink" title="聚簇与非聚簇表的数据存储方式"></a>聚簇与非聚簇表的数据存储方式</h2><p>我们假设有如下数据表：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552024-2614c000-b862-11e8-8009-4ec017ee5645.png" alt="image"></p>
<p>我们假设列 col1 是 primary key，那么，对应的聚簇索引存储结构就会如下：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552432-83f5d780-b863-11e8-987f-03913bcceb9e.png" alt="image"></p>
<p>（暂时不必关心 TID 和 RP，它们是事务 ID 和回滚指针）如上所示，聚簇索引除了存储 col1 的值之外，还会存储其它列的值（本例的 col2）。<br>如果 col2 设置了普通索引，对应地，col2 的索引存储结构如下：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552536-cd462700-b863-11e8-937d-777ee488ba49.png" alt="image"></p>
<p>可以看到，对应 B+ 树叶子节点上存储了对应行的主键的值。</p>
<p>抽象来看，InnoDB 通过如下结构存储主键索引（聚簇索引）：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552757-8a388380-b864-11e8-8cf6-ad0c46847e58.png" alt="image"></p>
<p>InnoDB 通过如下结构存储二级索引：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552771-915f9180-b864-11e8-8b3a-93da00f27aa7.png" alt="image"></p>
<p>作为参考，MyISAM（另一个 MySQL 存储引擎）是这样存储主键索引和二级索引的：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45552785-97ee0900-b864-11e8-8471-3bee5dd3a93e.png" alt="image"></p>
<h2 id="InnoDB-表中按主键顺序插入"><a href="#InnoDB-表中按主键顺序插入" class="headerlink" title="InnoDB 表中按主键顺序插入"></a>InnoDB 表中按主键顺序插入</h2><p>一般来讲，使用一个业务无关的自增（ AUTO_INCREMENT ）ID，可以保证数据在插入时会被按顺序写入。假设我们使用 UUID 作为聚簇索引，在插入数据的时候，聚簇索引所被插入的位置将变得完全随机。大量的随机插入会导致页分裂和碎片非常多。</p>
<p>下图展示了数据插入有序递增时，聚簇索引会如何存储插入的数据行：<br><img src="https://user-images.githubusercontent.com/5506906/45553171-c1f3fb00-b865-11e8-8175-2bb1a4562003.png" alt="image"></p>
<p>可以看到，因为主键是有序的，InnoDB 把每一条记录都存储在上一条记录的后面。当当前页即将写满时（之所以是即将而不是已经，是因为 InnoDB 会预留一点空间用于以后修改数据，默认预留页的 1/16 大小），下一条记录被插入时，将会写入到新的页中去。所有被插入的数据，都将有序地放到聚簇索引最后的位置上去。</p>
<p>对应地，如果使用 UUID 作为主键索引，InnoDB 将完全随机地将数据插入到聚簇索引对应的位置上去：</p>
<p><img src="https://user-images.githubusercontent.com/5506906/45553481-97ef0880-b866-11e8-88e5-441043983a2e.png" alt="image"></p>
<p>如上，因为新插入的行的主键不一定比之前插入的大（由于是 UUID，将会非常随机），所以 InnoDB 将无法简单地总是把新行插入到索引的最后，而是需要根据主键 ID 的值为它寻找合适的索引位置，并为其分配空间。使用 UUID 作为聚簇索引，有以下缺点：</p>
<ul>
<li>写入的目标页可能已经写入到磁盘而不只是存在于内存中，又或者目标页还没有被加载到内存中，InnoDB 在插入前需要先找到并从磁盘中读取目标页到内存中去，这会产生大量的磁盘随机 IO。</li>
<li>因为写入是乱序的，InnoDB 需要频繁地做页分裂操作，一遍为新的行分配空间。页分裂需要移动大量数据。</li>
<li>有序频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。</li>
</ul>
<p>所以，在使用 InnoDB 时应该尽可能使用单调递增的主键 ID 顺序插入数据。单调递增的主键 ID 并不只有 AUTO INCREMENT 一种方式，比如一些分布式发号器算法，也能产生递增的 ID 序列。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简述了为什么应该使用自增的 ID 而不是 UUID 作为 InnoDB 表的主键 ID。</p>
<p><em>注：本文截图摘自《高性能 MySQL》</em></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/09/04/redis-dict-rehash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/redis-dict-rehash/" itemprop="url">
                  Redis dict rehash
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-04 20:06:29" itemprop="dateCreated datePublished" datetime="2018-09-04T20:06:29+08:00">2018-09-04</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字典（<code>dict</code>）是 Redis 实现中非常常用的数据结构，比如用来作为 set 和 hash 的底层实现之一，dict 也是 Redis 数据库中 redisDb 用来存储所有数据的基本格式。</p>
<h2 id="dict-的实现"><a href="#dict-的实现" class="headerlink" title="dict 的实现"></a>dict 的实现</h2><h3 id="dictht-hash-table-amp-dictEntry"><a href="#dictht-hash-table-amp-dictEntry" class="headerlink" title="dictht(hash table) &amp; dictEntry"></a>dictht(hash table) &amp; dictEntry</h3><p>Redis 中 dict 结构其实封装了 hash table（ Redis 中叫做 dictht ），如下是 Redis4.0 中，<a href="https://github.com/antirez/redis/blob/4.0/src/dict.h#L69-74" target="_blank" rel="noopener">dictht 的定义</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// hash table 实际存储的位置 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;     <span class="comment">// table 的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     <span class="comment">// 已经使用的长度</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>如上，table 属性指向一个 <code>dictEntry</code> 指针数组的开始位置，（其实就是 <code>dictEntry</code> 指针数组）用来存储每一组键值对。size 则记录 table 的长度，used 用来记录已经存储的节点数量。</p>
<p>如下是 <a href="https://github.com/antirez/redis/blob/4.0/src/dict.h#L47-56" target="_blank" rel="noopener">dictEntry 的定义</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>如上，key 则是一个键值对的键，v 是对应的值。每个 dictEntry 除了存储键值之外，还有一个 next 指针，用来指向 hash 相同时的下一个节点，以解决 hash 冲突问题。</p>
<p>如下图，假如 k1/k2 对应的 hash 相同，则会通过 next 指针连接起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|  dictht  |</span><br><span class="line">+----------+    +----------+</span><br><span class="line">|  table   +---&gt;| dictEntry|</span><br><span class="line">|          |    +----------+</span><br><span class="line">|  size    |    |    0     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">|          |    +----------+        |  entry  | next |  entry  | next</span><br><span class="line">|  sizemask|    |    1     +-------&gt;+---------+-----&gt;+---------+-----&gt;NULL</span><br><span class="line">|          |    +----------+        | k1 | v1 |      | k2 | v2 |</span><br><span class="line">|  used    |    |    2     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">+----------+    +----------+</span><br><span class="line">                |    3     +-&gt;NULL</span><br><span class="line">                +----------+</span><br></pre></td></tr></table></figure>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>Redis4.0 中 <a href="https://github.com/antirez/redis/blob/4.0/src/dict.h#L76-82" target="_blank" rel="noopener">dict 的定义</a>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 key</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 value</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 比较 key</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁 key</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁 value</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>先看一下 dictType，由于 dictEntry 中的 key 是 <code>void*</code>，v 也可以是 <code>void*</code>，所以需要某种方式来操作具体的键和值。dictType 就定义了一组函数指针，dict 对象的 type 指针关联本 dict 对应的 key-value pair 实现的 dictType，以实现具体类型的计算哈希、复制键值、比较和销毁键值等操作。dict 通过这样的方式实现了多态。</p>
<p>dict 结构体中，prevdata 保存了需要传给 dictType 里的函数的特定参数（dictType 中各个函数签名中的 prevdata 指针）。</p>
<p>ht 是包含两个 dictht 对象的数组，ht[0] 存储数据，ht[1] 在 rehash 的时候会用到，下面就会提到。</p>
<p>rehashidx 记录 rehash 进度，本文后面会详细介绍。</p>
<p>在没有发生 rehash 的时候，ht[1] 是一个空的 dictht。</p>
<h2 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash 冲突"></a>hash 冲突</h2><p>所谓 hash table，本质是将 hash(key) 映射到自己的 table 数组中去。<br>对于一个 dict 对象，一个 dictEntry 经过下面的计算即可知道需要被映射到哪个位置：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(dictEntry-&gt;key);</span><br><span class="line">position = hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask;</span><br></pre></td></tr></table></figure></p>
<p>想象这样的情况，如果两个 key 的哈希值相同，或者哈希值 &amp; sizemask 相同，即两个不同的 key 被映射到 dictht.table 的同一个位置，也就是发生了 hash 冲突。</p>
<p>如上 dictEntry 结构中的 next 指针，Redis 通过这个指针将 hash 冲突的 dictEntry 连接到一起，以解决冲突。</p>
<p>由于 dictEntry 只有 next 指针，所以处于性能考虑，当 dictht 遇到 hash 冲突时，新的节点总是会被添加到这个链表的表头节点，也就是只需要 O(1) 时间复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">before: 包含 k1-v1 的 dictht：</span><br><span class="line">+----------+</span><br><span class="line">|  dictht  |</span><br><span class="line">+----------+    +----------+</span><br><span class="line">|  table   +---&gt;| dictEntry|</span><br><span class="line">|          |    +----------+</span><br><span class="line">|  size    |    |    0     +-&gt;NULL  +---------+ </span><br><span class="line">|          |    +----------+        |  entry  |  </span><br><span class="line">|  sizemask|    |    1     +-------&gt;+---------+ </span><br><span class="line">|          |    +----------+        | k1 | v1 | </span><br><span class="line">|  used    |    |    2     +-&gt;NULL  +---------+ </span><br><span class="line">+----------+    +----------+</span><br><span class="line">                |    3     +-&gt;NULL</span><br><span class="line">                +----------+</span><br><span class="line"></span><br><span class="line">after: 当 k2 与 k1 的 hash 冲突时，k2 会被插入到链表表头节点：</span><br><span class="line">+----------+</span><br><span class="line">|  dictht  |</span><br><span class="line">+----------+    +----------+</span><br><span class="line">|  table   +---&gt;| dictEntry|</span><br><span class="line">|          |    +----------+</span><br><span class="line">|  size    |    |    0     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">|          |    +----------+        |  entry  | next |  entry  | next</span><br><span class="line">|  sizemask|    |    1     +-------&gt;+---------+-----&gt;+---------+-----&gt;NULL</span><br><span class="line">|          |    +----------+        | k2 | v2 |      | k1 | v1 |</span><br><span class="line">|  used    |    |    2     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">+----------+    +----------+</span><br><span class="line">                |    3     +-&gt;NULL</span><br><span class="line">                +----------+</span><br></pre></td></tr></table></figure>
<h2 id="rehash-过程"><a href="#rehash-过程" class="headerlink" title="rehash 过程"></a>rehash 过程</h2><p>当 dictEntry 被不断插入到 dictht 中或不断被删除时，dictht 对象的 table size 对于当前存储元素个数来讲可能太小或者太大。<br>衡量所谓「太大」和「太小」的标准，叫做<strong>负载因子（ load factor ）</strong>，这个值的计算规则为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadFactor = dictht.used / dictht.size</span><br></pre></td></tr></table></figure>
<p>比如对于上面的例子，负载因子就是 2 / 4 = 0.5。</p>
<p>当：</p>
<ol>
<li>服务器执行 BGSAVE/BGREWRITEAOF 命令且负载因子大于 5 时，Redis 会对 dictht 扩容；</li>
<li>服务器没有执行 BGSAVE/BGREWRITEAOF 命令且负载因子大于 1 时，Redis 会对 dictht 扩容；</li>
<li>负载因子小于 0.1 时，Redis 会对 dictht 缩容。</li>
</ol>
<p>当满足这些条件时，将出发 Redis rehash 操作，具体步骤为：</p>
<ol>
<li>为 dict-&gt;ht[1] 分配空间，具体大小取决于目前是要扩容还是缩容，以及 ht[0].used（当前 dict 大小）：<br> a. 当扩容时，新的大小为第一个大于 ht[0].used * 2 的 2^n 值；<br> b. 当缩容时，新的大小为第一个 ≥ ht[0].used 的 2^n 值。</li>
<li>将 ht[0].table 中所有的键值对依次 rehash 到 ht[1].table 中去，即依次为每个 dictEntry 计算 key 的 hash，并映射到新的 dictht.table 中。</li>
<li>当 ht[0].table 所有 dictEntry 全部迁移到 ht[1].table 里之后，释放 ht[0]，并将 ht[1] 设置为 ht[0]，然后再在 ht[1] 创建空的 dictht。</li>
</ol>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>当 dict rehash 发生时，需要将 ht[0] 中所有 dictEntry 全部 rehash 到 ht[1] 中去。想象一下如果 dict 已经非常大时，这个操作将会非常慢，以至于影响 Redis 对外提供服务的性能。<br>所以在 Redis rehash 过程的实现中，这个过程并不是停机一次性完成的，而是会分多次进行，渐进式完成的。上面提到的 dict-&gt;rehashidx 属性，就是用来记录 rehash 流程的。</p>
<p>这个渐进式 rehash 大概的流程如下：</p>
<ol>
<li>为 dict-&gt;ht[1] 分配合适的空间，dict 此时同时持有 ht[0] 和 ht[1]；</li>
<li>将 dict-&gt;rehashidx 设置为 0，代表 rehash 工作开始；</li>
<li>当 rehash 期间，对 dict 执行的增、删、改、查操作时，Redis 除了执行操作外，还会将 dict-&gt;ht[0].table[dict-&gt;rehashidx] 上的 dictEntry rehash 到 dict-&gt;ht[1] 中，并将 rehashidx 加一；</li>
<li>随着 dict rehash 不断进行，最终，dict-&gt;ht[0] 上的所有元素都被 rehash 至 dict-&gt;ht[1] 中，rehash 过程完成，将 rehashidx 置为 -1;</li>
<li>释放 ht[0]，并将 ht[1] 设置为 ht[0]，然后再在 ht[1] 创建空的 dictht。</li>
</ol>
<p>在 rehash 过程中，如果有新的元素插入，则会直接被插入到 dict-&gt;ht[1] 中去，ht[0] 将不会再插入数据。<br>而这个过程中，dict-&gt;ht[0]、ht[1] 都有部分数据，因此在 rehash 进行时，dict 的查找、删除、更新都会在两个 dictht 对象上执行。比如删除一个 key，如果这个 key 在 dict-&gt;ht[0] 中不存在，还会再在 dict-&gt;ht[1] 中查找并删除（如果存在）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回顾了一下 Redis 中 dict 的实现，当遇到 hash 冲突时的解决办法，以及 Redis 中 dict 是如何扩容和缩容的。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/09/01/redis-data-structure-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/redis-data-structure-overview/" itemprop="url">
                  Redis data structure overview
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-01 01:52:13" itemprop="dateCreated datePublished" datetime="2018-09-01T01:52:13+08:00">2018-09-01</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>所有后端开发的同学，一般都会使用到 Redis 作为数据存储或缓存。在我所知的很多互联网公司，Redis 都发挥着难以替代的作用。本文试图简单介绍下，Redis 实现中用到的一些数据结构。</p>
<hr>
<h2 id="Redis-用户侧支持的数据结构"><a href="#Redis-用户侧支持的数据结构" class="headerlink" title="Redis 用户侧支持的数据结构"></a>Redis 用户侧支持的数据结构</h2><p>完整的 Redis 命令参考可以查看 <a href="http://redisdoc.com/" target="_blank" rel="noopener">redisdoc.com</a>。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>通过 key-value pair 的方式，存储字符串、整数、浮点数等对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---------+    +---------+</span><br><span class="line">|   key   +---&gt;|  value  |</span><br><span class="line">+---------+    +---------+</span><br></pre></td></tr></table></figure></p>
<p>虽然叫做「 string 」，但其实更像是一个字节序列（底层存储也是一个字节数组），所以其实你可以存储任何东西到 string 中去。比如把 Python pickle 序列化后的对象、一张图片的二进制序列等任何东西存储为 string。<br>之所以说 string 是字节数组，一部分原因是其提供了直接操作 bit 的指令。<br>不完全等同于 byte array 的是，string 对象某些场景下可以直接在服务端被解释为一个 int/double 对象，然后直接进行一些数字相关的运算（加、减）。<br>string 对象是 Redis 中最基础的类型，因为后面几乎所有数据类型存储的值，都是 string 类型。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Hash table，某些地方又被称为 <code>map</code>，概念上有点类似 Python 中的 dict 或 Golang 中的 map 等。其存储的是一系列 key-value 对。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>List 对象概念上可以理解为 Python 中的 list、Java 中的 List、Golang 中的 slice 等。之所以说概念上，是因为这几者底层实现上其实并不相同，只是都是对一组数据的集合的抽象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------+   +--------+--------+--------+--------+</span><br><span class="line">|  key  +--&gt;| value1 | value2 | ...... | value n|</span><br><span class="line">+-------+   +--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></p>
<p>（逻辑上 list 是这样的，实现上下面再讲）<br>Redis 中 list 对象可以插入数据到 list 头或尾上，由于其底层实现是一个双向链表（某些场景下不是），所以插入两端都是 O(1) 的。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 对象有点像是 Python 里的 set，其存储的是多个<strong>互不相同</strong>的元素。由于 set 底层使用 hash table 存储（同上，某些场景下不是），所以其大部分操作都是 O(1) 的。</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>zset 是有序集合，同 set 相似的是，其内部存储的元素也是不允许重复的。不同的是，set 中存储的元素是无序的，但是 zset 存储的元素是有序的。<br>通过为 zset 中每个元素设置一个 score，zset 根据元素的 score 排序。</p>
<h3 id="其他（略）"><a href="#其他（略）" class="headerlink" title="其他（略）"></a>其他（略）</h3><ul>
<li>HyperLogLog</li>
<li>GEO</li>
</ul>
<hr>
<h2 id="实现用户侧数据结构的底层结构"><a href="#实现用户侧数据结构的底层结构" class="headerlink" title="实现用户侧数据结构的底层结构"></a>实现用户侧数据结构的底层结构</h2><p>Redis 是通过 C 语言实现的，由于 C 语言的朴素，Redis 并没有直接实现上面提到的数据结构，而是通过构件了一系列基础的数据结构，经过对象系统对下层结构的封装，来实现上层面向用户的各种结构。<br>下面，先介绍下这些底层结构。</p>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>SDS 是「 simple dynamic string 」的缩写，是对 C 字符串的抽象（其实 C 语言没有字符串…… 2333）。<br>SDS 的定义如下（ <a href="https://github.com/antirez/redis/blob/4.0/src/sds.h#L44-73" target="_blank" rel="noopener">Redis4.0 sds 定义</a>，相比 3.0 及之前版本，目前版本包含多种格式的 sdshdr 定义）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相比 C char array，sds 有以下优点：</p>
<ol>
<li>获取字符串长度效率更优。C 字符串只是一个 ‘\0’ 结尾的 char 数组，如果需要获取字符串长度，需要遍历整个数组，遍历操作时间复杂度为 O(N)。而 sds len 属性记录了本身的长度，获取长度只需要 O(1) 复杂度。</li>
<li>避免数组长度溢出。类似 strcat(dst, src) 等函数，如果 dst 数组剩下的空间小于 src 的长度，则在字符串连接的时候会导致数组溢出。而在 sds 中，执行字符串拼接等修改操作时，会先通过 len、alloc 属性检查剩下的空间是否足够。当空间不足时，会先分配足够的空间。</li>
<li>减少内存分配次数。sds 会通过预申请内存，在连接字符串等操作时，减少对内存的申请操作。同时，如果 sds 所保存的字符串变短了，也并不会立即释放内存，而是通过 len 记录已使用，剩余空间作为 buffer 暂时保留。</li>
<li>二进制安全。因为 C 字符串会以 ‘\0’ 作为结束符，所以如果在 char array 中存储图片等二进制数据时，空字符会被认为是结束符。而 sds 通过 len 属性记录 buf 使用的长度，则可以避免这样的问题。</li>
<li>兼容部分 C 字符串函数。sds 也会在 buf 已使用的最后一位后（<code>sds-&gt;buf[sds-&gt;len]</code>）插入一个 ‘\0’，这样在 sds 存储文本数据时，可以方便地复用一些 <code>string.h</code> 已有的函数。</li>
</ol>
<h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><p>Redis 中 linkedlist 是一个双向链表（<a href="https://github.com/antirez/redis/blob/4.0/src/adlist.h#L36-54" target="_blank" rel="noopener">Redis4.0 linkedlist 定义</a>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p>
<p>每个节点类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---------+           +----------+        +----------+        +----------+</span><br><span class="line">|  list   |           | listNode |        | listNode |        | listNode |</span><br><span class="line">+---------+           +----------+  next  +----------+  next  +----------+  next</span><br><span class="line">|  head   +-----------&gt;          +--------&gt;          +--------&gt;          +-------&gt;NULL</span><br><span class="line">|         |           |  value   |        |  value   |        |  value   |</span><br><span class="line">|  tail   +-+  NULL&lt;--+          &lt;--------+          &lt;--------+          |</span><br><span class="line">|         | |     prev+----------+  prev  +----------+  prev  +-^--------+</span><br><span class="line">|  len: 3 | |                                                   |</span><br><span class="line">|         | +---------------------------------------------------+</span><br><span class="line">|  dup    +----&gt; ...</span><br><span class="line">|         |</span><br><span class="line">|  free   +----&gt; ...</span><br><span class="line">|         |</span><br><span class="line">|  match  +----&gt; ...</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure></p>
<p>list 结构通过 head、tail 记录了链表头尾指针，配合每个节点的 next、prev，方便从头或者从尾遍历等操作。<br>另外，dup/free/match 等函数指针，则是用于实现链表的多态特性：</p>
<ol>
<li>dup 函数用于复制链表节点保存的值</li>
<li>free 函数用于释放链表节点保存的值</li>
<li>match 函数用于比较节点的值与另一个输入 key 是否相同</li>
</ol>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict 类似 Python 中的 dict 或 Golang 中的 map。<br>在 Redis 中，dict 通过一个 dict 结构实现，底层通过一个 hashtable<dictentry> 存储数据。<br>tashtable 和 dictEntry 的定义如下（<a href="https://github.com/antirez/redis/blob/4.0/src/dict.h#L69-74" target="_blank" rel="noopener">Redis4.0 dict 定义</a>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;       <span class="comment">// hash table 实际存储的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      <span class="comment">// table 的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;      <span class="comment">// 已经使用的长度</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></dictentry></p>
<p>其中，dictEntry 是每个 key-value 对存储的结构，其 next 指针用于在 hash 冲突时，将多个 entry 连接一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|  dictht  |</span><br><span class="line">+----------+    +----------+</span><br><span class="line">|  table   +---&gt;| dictEntry|</span><br><span class="line">|          |    +----------+</span><br><span class="line">|  size    |    |    0     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">|          |    +----------+        |  entry  | next |  entry  | next</span><br><span class="line">|  sizemask|    |    1     +-------&gt;+---------+-----&gt;+---------+-----&gt;NULL</span><br><span class="line">|          |    +----------+        | k1 | v1 |      | k2 | v2 |</span><br><span class="line">|  used    |    |    2     +-&gt;NULL  +---------+      +---------+</span><br><span class="line">+----------+    +----------+</span><br><span class="line">                |    3     +-&gt;NULL</span><br><span class="line">                +----------+</span><br></pre></td></tr></table></figure></p>
<p>dict 的定义如下（<a href="https://github.com/antirez/redis/blob/4.0/src/dict.h#L76-82" target="_blank" rel="noopener">Redis4.0 dict 定义</a>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 key</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 value</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 比较 key</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁 key</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁 value</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ol>
<li>dictType 是一个包含一组针对不同类型 entry 特定操作函数的结构体。不同类型的 entry 通过不一样的实现，来达到多台的目的。</li>
<li>prevdata 保存了需要传给 dictType 里的函数的特定参数（如上函数签名的 prevdata 指针）</li>
<li>ht 是包含两个 dictht 对象的数组，ht[0] 存储数据，ht[1] 在 rehash 的时候会用到（这里只提一下，dict rehash 过程下次单写）</li>
<li>rehashidx 记录 rehash 进度，这里不做过多介绍。</li>
</ol>
<p>关于 dict 结构的一些细节，下次再详细介绍。</p>
<h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>skiplist（跳跃表） 是一种有序的结构，通过在每个节点中维护多个指向其他节点的指针来实现快速访问节点的目的。</p>
<p>skiplist 的定义如下（<a href="https://github.com/antirez/redis/blob/4.0/src/server.h#L760-774" target="_blank" rel="noopener">Redis4.0 skiplist 定义</a>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  <span class="comment">// 头、尾指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                 <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>如上，zskiplistNode 由于保存每个节点的数据和各种指针等，zskiplist 用于保存整个 skiplist 相关信息。</p>
<h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><p>当 set 中只包含整数元素时且元素不多时，底层的数据结构便是 intset。<br>intset 的定义如下（<a href="https://github.com/antirez/redis/blob/4.0/src/intset.h#L35-39" target="_blank" rel="noopener">Redis4.0 intset 定义</a>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p>其中 contents 数组用于存储数据，intset 按照存储数字的大小有序排列在 contents 数组中。length 属性记录集合中元素的个数。<br>encoding 记录 contents 数组中存储的元素的类型：</p>
<ul>
<li><code>INTSET_ENC_INT16</code> 存储 int16 类型整数</li>
<li><code>INTSET_ENC_INT32</code> 存储 int32 类型整数</li>
<li><code>INTSET_ENC_INT64</code> 存储 int64 类型整数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|  intset  |</span><br><span class="line">+----------+</span><br><span class="line">|  encoding|</span><br><span class="line">|   INTSET_ENC_INT16</span><br><span class="line">|          |</span><br><span class="line">|  length  |</span><br><span class="line">|   5      |</span><br><span class="line">|          |       +----+---+---+---+------+</span><br><span class="line">|  contents+------&gt;+ -4 | 0 | 3 | 6 | 1024 |</span><br><span class="line">+----------+       +----+---+---+---+------+</span><br></pre></td></tr></table></figure>
<p>当新增元素到 intset 中时，如果新元素比现有元素类型长时，比如向 INTSET_ENC_INT16 编码的 intset 插入一个 32 位整数时，intset 需要先升级（upgrade），才能添加元素。所谓 upgrade 是将此 intset 的 enconding 更新为更长 bit 的编码格式上。当 intset 升级后不会降级，哪怕删除长 bit 元素后剩下全是短 bit 元素。</p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist 是 list 和 hash 的一种底层实现。当 list 元素较少且只包含整数或短字符串时，底层会通过 ziplist 存储数据。<br>ziplist 是为了节约内存而设计的一种结构，本质上就是一个约束了特殊格式的 char array，或者更正确的说法，是字节序列。展开这个字节序列，大致约束的格式是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---------+--------+-------+--------+-----+--------+-------+ </span><br><span class="line">| zlbytes | zltail | zllen | entry1 | ... | entryN | zlend | </span><br><span class="line">+---------+--------+-------+--------+-----+--------+-------+</span><br></pre></td></tr></table></figure></p>
<p>每部分的含义是：</p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>sizeof</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td> zlbytes</td>
<td>uint32_t</td>
<td>4</td>
<td>记录 ziplist 长度（bytes）</td>
</tr>
<tr>
<td> zltail</td>
<td>uint32_t</td>
<td>4</td>
<td>记录 ziplist 尾节点距开始的字节数，通过 zltail 可以方便地找到尾节点地址</td>
</tr>
<tr>
<td> zllen</td>
<td>uint16_t</td>
<td>2</td>
<td>记录 ziplist 节点数量：当超过 2bit 长度时，真正的节点数量需要遍历整个 ziplist 才能得到</td>
</tr>
<tr>
<td> entry</td>
<td>ziplist 存储的元素</td>
<td>/</td>
<td>ziplist 存储的元素，具体长度由具体存储的内容决定</td>
</tr>
<tr>
<td> zlend</td>
<td>uint8_t</td>
<td>1</td>
<td>值衡为 0xFF，标记 ziplist 结束</td>
</tr>
</tbody>
</table>
<p>对于每个 entry 节点，又可以展开为这样的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+----------+---------+ </span><br><span class="line">| previous_entry_length | encoding | content |</span><br><span class="line">+-----------------------+----------+---------+</span><br></pre></td></tr></table></figure></p>
<p>每部分的含义是：</p>
<table>
<thead>
<tr>
<th>field</th>
<th>sizeof</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td> previous_entry_length</td>
<td>1 or 5</td>
<td>前一个元素的长度（bytes），分两种情况：1. 前一个元素小于 254 bytes，则使用一个字节记录；2. 前一个元素长度大于 254 bytes，则这个字段第一字节衡为 0xFE，后面 4 位表示前一个元素长度</td>
</tr>
<tr>
<td> encoding</td>
<td>1 or 2 or 5</td>
<td>记录当前元素的数据类型和长度（具体本文暂略）。</td>
</tr>
<tr>
<td> content</td>
<td>/</td>
<td>保存节点存储的数据</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Redis-是如何通过底层结构构件上层数据类型的"><a href="#Redis-是如何通过底层结构构件上层数据类型的" class="headerlink" title="Redis 是如何通过底层结构构件上层数据类型的"></a>Redis 是如何通过底层结构构件上层数据类型的</h2><p>上面介绍了用户侧使用的几种常见数据类型，也介绍了 Redis 底层用于支持上层结构而实现的一些结构。下面介绍下 Redis 是如何通过下层的结构构件上层的数据类型的。</p>
<h3 id="redisObject-对象"><a href="#redisObject-对象" class="headerlink" title="redisObject 对象"></a>redisObject 对象</h3><p>Redis 不直接实现上层的数据类型，是为了方便在不同场景下可以替换下层合适的数据结构，同时对上层使用屏蔽下层实现细节。在不同场景下，面对性能和内存占用不同而使用不同的下层结构支持同一个上层对象。</p>
<p><code>redisObject</code> 对象完成了这层转换（<a href="https://github.com/antirez/redis/blob/4.0/src/server.h#L585-593" target="_blank" rel="noopener">Redis4.0 redisObject 定义</a>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;             <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>如上结构，<code>type</code> 属性记录了对象的类型，对应上层面向用户的那些数据类型（string/list/hash 等）。对应的类型，可以通过在 redis-cli 中调用 <code>TYPE key</code> 查看每个 key 对应的类型。</p>
<p>而 encoding 则对应着这个 redisObject 下层使用的数据类型（如上 sds/ziplist/dict 等），常见的 encoding 有：</p>
<table>
<thead>
<tr>
<th>encoding</th>
<th>对应的底层结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>sds</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的 sds</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>dict</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>linkedlist</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>ziplist</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>intset</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>skiplist</td>
</tr>
</tbody>
</table>
<p>对应的下层结构，可以通过在 redis-cli 中调用 <code>OBJECT ENCODING key</code> 查看每个 key 对应的底层实现的数据结构。</p>
<h3 id="string-–-gt-int-raw-embstr"><a href="#string-–-gt-int-raw-embstr" class="headerlink" title="string –&gt; int/raw/embstr"></a>string –&gt; int/raw/embstr</h3><p>string 类型在不同场景下，下层分别由 int/raw/embstr 编码方式来实现（ embstr 是经过优化的用于保存短字符串的编码方式）。</p>
<ol>
<li>如果 value 是一个整数，且整数长度在 8 bytes 以内，则 string 对象的编码类型为 int，redisObject 的 ptr 指针将指向一个 long 型对象。</li>
<li>如果 value 是一个字符串值，且长度大于 32 字节，则 string 对象编码类型为 raw，对应 redisObject 的 ptr 指针将指向一个 sds 对象。</li>
<li>如果 value 是一个字符串值，且长度小于等于 32 字节，则会通过 embstr 编码保存。</li>
</ol>
<p>当 int 编码的 value 被重新赋值为字符串或通过 incr 等命令自增到超过 64 位长度时，则 Redis 会将其编码方式从 int 转换为 raw。<br>当 embstr 编码的 value 发生修改时，编码方式会变为 raw 方式，换言之，embstr 是 read only 的。</p>
<h3 id="list-–-gt-ziplist-linkedlist"><a href="#list-–-gt-ziplist-linkedlist" class="headerlink" title="list –&gt; ziplist/linkedlist"></a>list –&gt; ziplist/linkedlist</h3><p>list 的底层实现则分为 ziplist 和 linkedlist 两种。</p>
<ol>
<li>当 list 中所有元素长度都小于 <code>list-max-ziplist-value</code> 字节，且元素数量少于 <code>list-max-ziplist-entries</code> 时，底层会选择使用 ziplist。</li>
<li>否则，使用 linkedlist。</li>
</ol>
<p>当 ziplist 编码存储的 list 不满足上面 <code>1</code> 的两个条件任意一个时，Redis 就会将对应 value 的编码方式从 ziplist 转换为 linkedlist。</p>
<h3 id="hash-–-gt-ziplist-hashtable"><a href="#hash-–-gt-ziplist-hashtable" class="headerlink" title="hash –&gt; ziplist/hashtable"></a>hash –&gt; ziplist/hashtable</h3><p>hash 的底层实现可以为 ziplist 或者 hashtable 两种格式。</p>
<ol>
<li>当 hash 对象所有 key-value pair 长度都小于 <code>hash-max-ziplist-value</code>，且 key-value pair 数量小于 <code>hash-max-ziplist-entries</code> 时，底层会使用 ziplist 保存 hash 对象。</li>
<li>否则，使用 hashtable。</li>
</ol>
<p>当使用 ziplist 作为 hash 底层存储结构时，每个 key-value 对会连续地放置在 ziplist 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+---------+--------+-------+------+--------+------+--------+-----+------+--------+-------+</span><br><span class="line">| zlbytes | zltail | zllen | key1 | value1 | key2 | value2 | ... | keyN | valueN | zlend | </span><br><span class="line">+---------+--------+-------+--^---+---^----+------+--------+-----+------+--------+-------+</span><br><span class="line">                              |       |</span><br><span class="line">                              +-------+</span><br><span class="line">                            key-value 对</span><br></pre></td></tr></table></figure></p>
<p>同 list，当 hash 对象不满足如上 <code>1</code> 的两个条件任意一个时，编码方式就会从 ziplist 转换为 hashtable。</p>
<h3 id="set-–-gt-intset-hashtable"><a href="#set-–-gt-intset-hashtable" class="headerlink" title="set –&gt; intset/hashtable"></a>set –&gt; intset/hashtable</h3><p>set 的底层实现由 intset 和 hashtable 两种。</p>
<ol>
<li>当 set 所有元素都是整数对象，且元素数量小于 <code>set-max-intset-entries</code> 时，使用 intset 作为底层编码方式。</li>
<li>否则，使用 hashtable。</li>
</ol>
<p>如下分别是使用 intset 和 hashtable 时，set 对象的存储方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|  redisObject  |</span><br><span class="line">+---------------+         +-------------+</span><br><span class="line">|  type         |         |  intset     |</span><br><span class="line">|   REDIS_SET   |         +-------------+</span><br><span class="line">+---------------+         |  encoding   |</span><br><span class="line">|  encoding     |         |   INTSET_ENC_INT16</span><br><span class="line">|   REDIS_ENCODING_INTSET +-------------+ </span><br><span class="line">+---------------+         |  length     |</span><br><span class="line">|  ptr          +--------&gt;|   3         |</span><br><span class="line">+---------------+         +-------------+   +---+---+---+</span><br><span class="line">|  ...          |         |  contents   +--&gt;| 1 | 3 | 5 |</span><br><span class="line">+---------------+         +-------------+   +---+---+---+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">|  redisObject  |</span><br><span class="line">+---------------+         +-------------+</span><br><span class="line">|  type         |         |  dict       |</span><br><span class="line">|   REDIS_SET   |         +-------------+</span><br><span class="line">+---------------+         | StringObject|</span><br><span class="line">|  encoding     |         |  &quot;haha&quot;     +--&gt;NULL</span><br><span class="line">|   REDIS_ENCODING_HT     +-------------+</span><br><span class="line">+---------------+         | StringObject|</span><br><span class="line">|  ptr          +--------&gt;+  &quot;hehe&quot;     +--&gt;NULL</span><br><span class="line">+---------------+         +-------------|</span><br><span class="line">|  ...          |         | StringObject|</span><br><span class="line">+---------------+         |  &quot;keke&quot;     +--&gt;NULL</span><br><span class="line">                          +-------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="zset-–-gt-ziplist-skiplist"><a href="#zset-–-gt-ziplist-skiplist" class="headerlink" title="zset –&gt; ziplist/skiplist"></a>zset –&gt; ziplist/skiplist</h3><p>有序集合有 ziplist 和 skiplist 两种方式作为底层的存储结构。</p>
<ol>
<li>当 zset 保存的元素小于 <code>zset-max-ziplist-entries</code> 个，且所有元素长度都小于 <code>zset-max-ziplist-value</code> 字节时，zset 底层通过 ziplist 存储。</li>
<li>否则，使用 skiplist 存储。</li>
</ol>
<p>同上面其他结构一样，当 <code>1</code> 条件任一不满足时，底层的数据存储结构将转换为第二种。</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单总结了下 Redis 用户端常用的数据结构，以及底层抽象的各种数据结构，以及二者是如何组合起来的。</p>
<p>Redis 面向用户侧的各种数据结构，并不直接实现，而是通过对象系统，在特定的条件下选择特定的底层结构，以在效率和存储空间之间平衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     +----------+         +----------+               +----------+         +----------+</span><br><span class="line">     |  string  |         |   list   |               |   zset   |         |   ...    |</span><br><span class="line">     +----+-----+         +----+-----+               +----+-----+         +----------+</span><br><span class="line">          |                    |                          |                                          </span><br><span class="line">         / \                   |      +-------------------+                             </span><br><span class="line">        / | \                  |      |                   |                                  </span><br><span class="line">       /  |  \                 |      |                   |                                                           </span><br><span class="line">    +-/   |   \----+           +--+---+-------+           +----------------------------+                              </span><br><span class="line">    |     |        |              |   |       |                                        |                </span><br><span class="line">+---v-+  +v----+  +v-------+  +---v---v-+  +--v--------+  +-----------+  +--------+  +-v--------+  +-----+</span><br><span class="line">| int |  | raw |  | embstr |  | ziplist |  | linkedlist|  | hashtable |  | intset |  | skiplist |  | ... |</span><br><span class="line">+-----+  +-----+  +--------+  +----^----+  +-----------+  +---^-----^-+  +-^------+  +----------+  +-----+</span><br><span class="line">                                   |                          |     |      |   </span><br><span class="line">                                   |                          |     |      |   </span><br><span class="line">                                   |                          |     |      |  </span><br><span class="line">                                   |   +----------+           |   +-+------+-+ </span><br><span class="line">                                   +---+   hash   +-----------+   |    set   |</span><br><span class="line">                                       +----------+               +----------+</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/05/12/lets-encrypt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/lets-encrypt/" itemprop="url">
                  通过 Lets's Encrypt 启用 HTTPS
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-12 17:49:35" itemprop="dateCreated datePublished" datetime="2018-05-12T17:49:35+08:00">2018-05-12</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>记录下通过 Lets’s Encrypt 开启 HTTPS 加成的步骤。这里以 Ubuntu16.04 + nginx 为例。我原本服务器 nginx 就已经配置好对应的域名，这里略过。</p>
<p>首先，安装 certbot ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python-certbot-nginx</span><br></pre></td></tr></table></figure></p>
<p>开放 443 端口，先检查下防火墙：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure></p>
<p>如果防火墙没有打开，是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xlzd$ sudo ufw status</span><br><span class="line">Status: inactive</span><br></pre></td></tr></table></figure></p>
<p>那就什么也不管就好。如果开了，大概输出是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">Nginx HTTP                 ALLOW       Anywhere                  </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure></p>
<p>如果防火墙处于打开状态，执行一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow &apos;Nginx Full&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以生成证书了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx -d fuckthe.app -d www.fuckthe.app</span><br></pre></td></tr></table></figure></p>
<p>第一次执行的时候，会提示你输入一个邮箱地址。</p>
<p>等执行成功之后，会看到大概这样的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">1: No redirect - Make no further changes to the webserver configuration.</span><br><span class="line">2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for</span><br><span class="line">new sites, or if you&apos;re confident your site works on HTTPS. You can undo this</span><br><span class="line">change by editing your web server&apos;s configuration.</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Select the appropriate number [1-2] then [enter] (press &apos;c&apos; to cancel): 1</span><br></pre></td></tr></table></figure></p>
<p>选 2 即可，会被自动写入到 nginx 配置中去。</p>
<p>在 crontab 中配置一下自动更新证书：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * 1 /usr/bin/certbot renew --dry-run &gt;&gt; /var/<span class="built_in">log</span>/le-renew.log</span><br><span class="line">35 2 * * 1 /usr/bin/nginx -s reload</span><br></pre></td></tr></table></figure></p>
<p>下次再要加新域名的时候，只需继续执行 <code>sudo certbot --nginx -d domain.com</code> 就可以啦~</p>
<p>Done.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2018/02/03/process-vs-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/process-vs-thread/" itemprop="url">
                  关于进程与线程
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-03 22:08:22" itemprop="dateCreated datePublished" datetime="2018-02-03T22:08:22+08:00">2018-02-03</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程（process）和线程（thread）应该是技术面试中最经常问到的知识点之一了。本文尝试简单总结下，进程与线程的一些区别。</p>
<p>在一开始，计算机并没有「进程」、「线程」这样的概念，计算机的功能就是输入 → 计算 → 输出。绝大部分时间里，其实计算机都是在等待用户的输入，显然这样的方式非常低效，毕竟人的手速怎么也无法跟计算机运算速度相提并论。</p>
<p>于是，人们开始把要执行的指令预算写到纸带、磁带或磁盘等介质上，然后将这些指令交给计算机去执行。一个专门的程序负责从对应的存储介质上读取指令序列，并交给计算机进行执行。计算机的执行过程不需要再人肉实时输入指令，少了大量等待时间，效率自然上升了很多很多。这个专门的程序，就是原始的操作系统——批处理操作系统。</p>
<p>批处理操作系统虽然解决了程序执行的性能问题，但是还是有一个缺点，计算机同时只能执行一个任务（程序）。如果这个程序需要大量 IO 操作，在 IO 操作发生的过程中，其实 CPU 是空闲的，要是这个空闲时间可以被利用起来，那就更好了。</p>
<p>为了进一步提升计算机的运算效率，「进程」就此诞生了。用进程的概念来抽象上面提到的一个任务（程序），每个程序就是一个进程，有自己独立的内存空间，程序间互不相关，操作系统负责来调度各个程序。这时 CPU 虽然还是单核的，但是操作系统通过分时的方式，把 CPU 的时间分成非常多的片段，每个片段内执行一个进程的指令，当这个时间片结束之后操作系统负责调度 CPU 执行另一个程序的指令。从 CPU 的角度来看，同一时间还是只有一个程序在执行，但是由于这里的时间片非常非常小，人的视角上，感受到的就像是多个程序在一起「同时」运行一样。</p>
<p>进程虽然有各自独立的内存空间，多个进程间互不相关。但是很多场景下其实需要两个程序有办法传递信息（通信），如果两个进程运行的时候如果有办法通过某种方式进行通信，会让程序的设计更加灵活方便。于是，进程间通信出现了，像管道、消息队列、信号等等，都可以实现两个进程间通信。</p>
<p>多进程的出现使得一个 CPU 可以「同时」执行多个不同的程序，但是在一个程序内部，指令依然是串行处理的。其实很多场景下，就算是一个程序内部，多个子任务也可以被设计为独立并行执行。为了让一个程序内部的多个子模块可以并行执行，「线程」的概念诞生了。线程是对进程内子任务的抽象，一个进程可以有多个子任务（线程）在同时执行，这些子任务会共享同一个进程的数据。<strong>「线程」的概念出现后，操作系统调度的最小单位变成了线程，而进程成为了操作系统分配资源的最小单位。</strong></p>
<p>多线程多进程的出现虽然让多任务并行处理的性能大大提升，但其实 CPU 角度上看本质所有的任务还是在串行执行，并不是真正的并行。直到多核 CPU 的出现，操作系统负责将不同的线程调度到多个 CPU 上执行，实现真正意义上的并行执行。</p>
<p>在编程开发中，其实并不是使用多线程、多进程就一定是好的，需要考虑具体的场景，根据不同业务场景选择合适的模型。比如 Redis 是单进程单线程，而 Nginx 可以使用多进程也可以使用多线程，他们却都是性能非常高的应用。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2017/11/30/sync-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/sync-hexo/" itemprop="url">
                  在多台机器间同步 Hexo 配置和数据
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-30 20:07:09" itemprop="dateCreated datePublished" datetime="2017-11-30T20:07:09+08:00">2017-11-30</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>把博客迁移到 hexo 后，开始考虑如何同步 hexo 的配置和数据，以便在多台电脑上无痛无缝切换。</p>
<p>解决思路：GitHub。</p>
<p>如果需要定制 theme，最好将对应的 theme fork 到自己的 GitHub 中，对 theme 的修改都同步到自己 fork 的仓库中去。方便管理自己对 theme 的修改。</p>
<p>首先在 hexo 根目录下初始化仓库，并将 themes 中对应的 theme 通过 git submodule 管理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> xlzd.github.io</span><br><span class="line">$ git init</span><br><span class="line">$ git checkout -b hexo-source</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"init hexo source"</span></span><br><span class="line">$ git remote add origin git@github.com:xlzd/xlzd.github.io.git</span><br><span class="line">$ git submodule add git@github.com:xlzd/hexo-theme-freemind.386.git themes/freemind.386</span><br><span class="line">$ git push origin hexo-source</span><br></pre></td></tr></table></figure>
<hr>
<p>在另一台机器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:xlzd/xlzd.github.io.git</span><br><span class="line">$ <span class="built_in">cd</span> xlzd.github.io</span><br><span class="line">$ git checkout hexo-source</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo generate &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xlzd.me/2017/11/21/crawler-archive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlzd">
      <meta itemprop="description" content="blog of xlzd">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xlzd 杂谈">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/crawler-archive/" itemprop="url">
                  爬虫博客归档
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-21 22:38:50" itemprop="dateCreated datePublished" datetime="2017-11-21T22:38:50+08:00">2017-11-21</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇博客将之前写过的一些爬虫相关的文章整理一个列表。<br>由于上一份工作中写了大量的爬虫，顺便写了几篇入门级的爬虫相关文章，本来计划再多写点爬虫相关高难度技巧的，但是不想再碰爬虫，就作罢了。</p>
<p>这里将过去写过的相关文章列举如下，以后应该再也不碰爬虫相关的任何问题了（声明：由于时间原因，所以不保证文中的方法现在依然可用，也不保证其准确性，仅供参考~）：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/20410446" target="_blank" rel="noopener">爬虫必备——requests</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20413379" target="_blank" rel="noopener">Web Crawler with Python - 01. 准备</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20413828" target="_blank" rel="noopener">Web Crawler with Python - 02. 简单的尝试</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20416894" target="_blank" rel="noopener">番外篇. 搭建称手的Python开发环境</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20423182" target="_blank" rel="noopener">Web Crawler with Python - 03. 豆瓣电影 TOP250</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20430122" target="_blank" rel="noopener">Web Crawler with Python - 04. 另一种抓取方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20432575" target="_blank" rel="noopener">Web Crawler with Python - 05. 存储</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20435541" target="_blank" rel="noopener">Web Crawler with Python - 06. 海量数据的抓取策略</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20471442" target="_blank" rel="noopener">Web Crawler with Python - 07. 反爬机制<1></1></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20494731" target="_blank" rel="noopener">Web Crawler with Python - 08. 模拟登录</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20546546" target="_blank" rel="noopener">Web Crawler with Python - 09. 通过爬虫找出我和轮子哥之间的最短关注链</a></li>
</ul>
<p>从上面文中的很多地方都可以看出，我给自己挖了好多坑，准备之后再填上，不过就目前来看，我暂时并不打算填坑了~~~</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="xlzd">
            
              <p class="site-author-name" itemprop="name">xlzd</p>
              <p class="site-description motion-element" itemprop="description">blog of xlzd</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xlzd" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/xlzd" target="_blank" title="知乎" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          
          <div class="motion-element">
            <script type="text/javascript" src="//ra.revolvermaps.com/0/0/6.js?i=0q7scpwe1yy&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=lucida_console&amp;l=0" async="async"></script>
          </div>
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 1926 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xlzd</span>

  

  
</div>


  



  <div class="powered-by">Powered by <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  

  

  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

</body>
</html>
